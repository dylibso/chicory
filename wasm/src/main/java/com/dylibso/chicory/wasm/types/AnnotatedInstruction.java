package com.dylibso.chicory.wasm.types;

import com.dylibso.chicory.wasm.InvalidException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * An {@link Instruction} enhanced with metadata derived from control flow analysis.
 * This includes information about block depth, target labels for branches, and the
 * enclosing block's instruction (scope). This is generated by the Parser.
 */
public final class AnnotatedInstruction extends Instruction {
    /**
     * A constant indicating that a label (true, false, or table entry) is not defined
     * for this instruction, typically because the instruction is not a branching one
     * or the specific branch condition doesn't apply.
     */
    public static final int UNDEFINED_LABEL = -1;

    // metadata fields
    private final int depth;
    private final int labelTrue;
    private final int labelFalse;
    private final List<Integer> labelTable;
    private final Instruction scope;

    private AnnotatedInstruction(
            int address,
            OpCode opcode,
            long[] operands,
            int depth,
            int labelTrue,
            int labelFalse,
            List<Integer> labelTable,
            Instruction scope) {
        super(address, opcode, operands);
        this.depth = depth;
        this.labelTrue = labelTrue;
        this.labelFalse = labelFalse;
        this.labelTable = labelTable;
        this.scope = scope;
    }

    /**
     * Returns the target instruction index for the 'true' branch condition.
     * Applicable for {@code BR}, {@code BR_IF}, {@code IF}, {@code ELSE}.
     * For {@code BR} and {@code ELSE}, this is the only target.
     * For {@code BR_IF} and {@code IF}, this is the target if the condition is true.
     * Returns {@link #UNDEFINED_LABEL} if not applicable.
     *
     * @return the target instruction index for the true condition, or {@link #UNDEFINED_LABEL}.
     */
    public int labelTrue() {
        return labelTrue;
    }

    /**
     * Returns the target instruction index for the 'false' branch condition.
     * Applicable for {@code BR_IF} and {@code IF}. This is the target if the condition is false.
     * This usually points to the instruction immediately following the {@code BR_IF} or the
     * instruction following the {@code ELSE} block (or {@code END} if no {@code ELSE}).
     * Returns {@link #UNDEFINED_LABEL} if not applicable.
     *
     * @return the target instruction index for the false condition, or {@link #UNDEFINED_LABEL}.
     */
    public int labelFalse() {
        return labelFalse;
    }

    /**
     * Returns the table of target instruction indices for {@code BR_TABLE} or {@code TRY_TABLE}.
     * The actual target is determined by an index popped from the stack at runtime.
     * The last entry in the list corresponds to the default target.
     * For {@code TRY_TABLE}, labels correspond to handler blocks.
     * Returns an empty list if not applicable.
     *
     * @return an unmodifiable list of target instruction indices, or an empty list.
     */
    public List<Integer> labelTable() {
        return labelTable;
    }

    /**
     * Returns the nesting depth of the control block (e.g., {@code BLOCK}, {@code LOOP}, {@code IF})
     * to which this instruction belongs. The top level has depth 0.
     *
     * @return the control block nesting depth.
     */
    public int depth() {
        return depth;
    }

    /**
     * Returns the instruction that opened the current control flow scope
     * (e.g., {@code BLOCK}, {@code LOOP}, {@code IF}, {@code TRY_TABLE}).
     * Returns null if this instruction is at the top level (depth 0).
     *
     * @return the opening instruction of the current scope, or null.
     */
    public Instruction scope() {
        return scope;
    }

    @Override
    public String toString() {
        return "AnnotatedInstruction{"
                + "instruction="
                + super.toString()
                + ", depth="
                + depth
                + ", labelTrue="
                + labelTrue
                + ", labelFalse="
                + labelFalse
                + ", labelTable="
                + labelTable
                + ", scope="
                + scope
                + '}';
    }

    /**
     * Creates a new builder for constructing an {@link AnnotatedInstruction}.
     *
     * @return a new {@link Builder} instance.
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Builder for creating {@link AnnotatedInstruction} instances.
     * This is used internally by the parser during control flow analysis.
     */
    public static final class Builder {
        private Instruction base;
        private int depth;
        private Optional<Integer> labelTrue = Optional.empty();
        private Optional<Integer> labelFalse = Optional.empty();
        private Optional<List<Integer>> labelTable = Optional.empty();
        private Optional<Instruction> scope = Optional.empty();

        private Builder() {}

        /**
         * Returns the {@link OpCode} of the base instruction.
         *
         * @return the opcode.
         */
        public OpCode opcode() {
            return base.opcode();
        }

        /**
         * Returns the {@link Instruction} that defines the current scope, if set.
         *
         * @return an Optional containing the scope instruction, or empty.
         */
        public Optional<Instruction> scope() {
            return scope;
        }

        /**
         * Sets the base {@link Instruction} to be annotated.
         *
         * @param ins the base instruction.
         * @return this builder instance.
         */
        public Builder from(Instruction ins) {
            this.base = ins;
            return this;
        }

        /**
         * Sets the control flow nesting depth.
         *
         * @param depth the depth value.
         * @return this builder instance.
         */
        public Builder withDepth(int depth) {
            this.depth = depth;
            return this;
        }

        /**
         * Sets the target label for the 'true' condition.
         *
         * @param label the target instruction index.
         * @return this builder instance.
         */
        public Builder withLabelTrue(int label) {
            this.labelTrue = Optional.of(label);
            return this;
        }

        /**
         * Sets the target label for the 'false' condition.
         *
         * @param label the target instruction index.
         * @return this builder instance.
         */
        public Builder withLabelFalse(int label) {
            this.labelFalse = Optional.of(label);
            return this;
        }

        /**
         * Updates the 'false' label only if it currently matches the 'true' label.
         * Used to handle implicit 'else' branches for 'if' blocks without an explicit 'else'.
         *
         * @param label the new target instruction index for the false condition.
         * @return this builder instance.
         */
        public Builder updateLabelFalse(int label) {
            if (this.labelFalse.equals(this.labelTrue)) {
                this.labelFalse = Optional.of(label);
            }
            return this;
        }

        /**
         * Sets the label table for {@code BR_TABLE} or {@code TRY_TABLE} instructions.
         *
         * @param labelTable the list of target instruction indices.
         * @return this builder instance.
         */
        public Builder withLabelTable(List<Integer> labelTable) {
            this.labelTable = Optional.of(labelTable);
            return this;
        }

        /**
         * Sets the instruction that opened the current control flow scope.
         *
         * @param scope the opening instruction (e.g., BLOCK, LOOP, IF).
         * @return this builder instance.
         */
        public Builder withScope(Instruction scope) {
            this.scope = Optional.of(scope);
            return this;
        }

        /**
         * Builds the {@link AnnotatedInstruction} instance.
         * Performs assertions to ensure metadata consistency based on the opcode.
         *
         * @return the constructed {@link AnnotatedInstruction}.
         * @throws InvalidException if required labels are missing for branching instructions.
         * @throws AssertionError if scope information is inconsistent with the opcode.
         */
        public AnnotatedInstruction build() {
            switch (base.opcode()) {
                case BLOCK:
                case LOOP:
                case END:
                case IF:
                case TRY_TABLE:
                    assert (scope.isPresent());
                    break;
                default:
                    assert (scope.isEmpty());
                    break;
            }
            switch (base.opcode()) {
                case BR_IF:
                case IF:
                    if (labelFalse.isEmpty()) {
                        throw new InvalidException("unknown label " + base);
                    }
                    // fallthrough
                case ELSE:
                case BR:
                    if (labelTrue.isEmpty()) {
                        throw new InvalidException("unknown label " + base);
                    }
                    break;
                default:
                    assert (labelTrue.isEmpty());
                    assert (labelFalse.isEmpty());
                    break;
            }
            switch (base.opcode()) {
                case BR_TABLE:
                case TRY_TABLE:
                    if (labelTable.isEmpty()) {
                        throw new InvalidException("unknown label table" + base);
                    }
                    break;
                default:
                    assert (labelTable.isEmpty());
                    break;
            }

            return new AnnotatedInstruction(
                    base.address(),
                    base.opcode(),
                    base.operands(),
                    depth,
                    labelTrue.orElse(UNDEFINED_LABEL),
                    labelFalse.orElse(UNDEFINED_LABEL),
                    labelTable.orElse(List.of()),
                    scope.orElse(null));
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || !(o instanceof AnnotatedInstruction)) {
            return false;
        }
        AnnotatedInstruction that = (AnnotatedInstruction) o;
        return depth == that.depth
                && labelTrue == that.labelTrue
                && labelFalse == that.labelFalse
                && Objects.equals(labelTable, that.labelTable)
                && Objects.equals(scope, that.scope);
    }

    @Override
    public int hashCode() {
        return Objects.hash(depth, labelTrue, labelFalse, labelTable, scope);
    }
}
